![](https://i.imgur.com/6MlU9At.jpg)

순발력 테스트 게임을 만들어 봅시다!


## 목표
---

우리는 무작위 LED가 켜지는 열 (첫 번째 열은 A, 마지막 열은 E)에 해당하는 키 (ADKeypad의)를 클릭해야하는 게임을 만들 것입니다. 경기가 진행됨에 따라 LED가 켜지는 속도가 빨라지고 빨라집니다. 다음 방법을 배우게됩니다.

- 마이크로 비트가있는 ADKeypad를 사용하십시오.
- 재귀 적으로 함수를 사용하십시오.
- while 루프를 사용하십시오.
- 손재주를 향상 시키십시오!

![](https://i.imgur.com/pPKW0KA.jpg)  

## 재료 및 전제 조건
---

1 x [BBC 마이크로 : 비트] (http://www.icbanq.com/shop/templete_list.asp?t_idx=163)
1 x 마이크로 USB 케이블
1 x F-F 점퍼 전선
1 x [ADKeypad] (http://www.icbanq.com/shop/templete_list.asp?t_idx=163)
또는
[ElecFreaks Micro : 비트 팅커 키트] (http://www.icbanq.com/shop/templete_list.asp?t_idx=163) (위의 모든 구성 요소가 포함되어 있습니다.)

if-else 문, 변수 등에 대한 경험이 필요합니다.


## 만드는 방법
---

### 1 단계

![](https://i.imgur.com/36IKWCb.jpg)  

ADkeypad를 Pin0에 연결하고, 양극 도선이 노란색 신호 핀에 연결되고 음극선이 브레이크 아웃 보드의 검정색 접지 핀에 연결되어 있는지 확인하십시오.

### 2 단계

![](https://i.imgur.com/ZElg0dw.png)  
불이 켜지는 LED를 쉽게 랜덤화할 수 있도록 재귀 적으로 함수를 사용합니다. 재귀 적으로 사용되는 함수는 자신을 (!) 호출하여 최종 목표를 달성합니다. 이런 이유로 plotLight 함수를 만들었습니다. 기능을 다루지 않은 경우 여기로 이동하십시오.

그럼 난 0과 4 사이의 정수로 randomLightXIndex과 randomLightYIndex 두 변수를 설정합니다. 이것은 특정 LED에 해당합니다. 이렇게하면 불이 켜지는 LED의 무작위성 (실제 무작위성이 실제로 생성 될 수있는 위치에 대해 논의하지 말아야 함)을 보장하므로 매번 게임이 달라지고 예측할 수 없게됩니다.

또한 변수 bool을 true로 설정했습니다. 이것이 지금은 분명하지는 않지만, 나중에 유용 할 것입니다. (사실 이것은 나중에 함수가 나머지 부분이 더해진 후 추가하기로 결정한 나중의 추가 사항입니다. 나중에이 이유가 나타납니다). 이것은 코딩에서 일반적인 기술입니다 (특히 while 루프 사용).

어려움을 증가시키기 위해, 시간 변수가 유용 할 수 있다는 것이 내 판단이었다. 우리는이 LED를 사용하여 하나의 LED 조명과 다음 LED 사이의 정지 시간을 줄입니다. 우리는 게임을 불가능하게하지 않기 위해 0.5 초의 휴지 시간의 하한을 설정했습니다. 함수를 재귀 적으로 호출 할 때 일시 중지 시간을 수정하는 if 문은 함수가 호출 될 때마다 일시 중지 시간을 줄이는 것입니다.

루프 안에 if-else 문을 많이 만들었습니다. 이 문은 키보드의 버튼이 눌려 졌는지 여부와 버튼이 켜져있는 LED의 x 좌표에 해당하는지 주기적으로 확인합니다. 키패드를 누르기 만하면 마이크로 비트의 핵심 모듈에서 이벤트 리스너가 흔들 리거나 버튼을 누르는 것과 같은 방식으로 반응 할 수 있기 때문에이 작업을 수행해야합니다. 따라서 우리는 자체 이벤트 리스너를 만들어야했습니다. 이 이벤트 리스너는 bool (이전에 생성 한)이 true 인 경우에만 실행됩니다.


### 3 단계

![](https://i.imgur.com/0WIqH6P.png)  

if-else 문에서 어떤 키가 눌 렸는지, LED 열 (x 좌표)에 해당하는지 확인합니다. 그렇다면 우리는 다시 기능을 호출합니다. 이것은 재귀 프로그래밍이 작동하는 방법입니다. 함수를 다시 호출하면 기본적으로 새로운 LED로 시작합니다. 함수를 다시 호출 할 때 시간 변수의 값이 감소하므로 일시 중지 기간이 짧아집니다.
  
포인트 LED를 뽑지 않았다는 것에 유의하십시오. 이는 플레이어를 혼란스럽게하지 않도록 각 라운드마다 하나 이상의 LED가 없도록하기위한 것입니다. 게임을 더욱 어렵게 만들고 싶다면 여러 개의 LED를 표시하고 가장 최근에 켜진 LED 만 재생하면됩니다. 그것을 연장으로 간주하십시오!
흥미롭게도 나는 bool을 false로 설정했다. 왜?


### 4 단계

![](https://i.imgur.com/qKCa1J1.png)  

bool은 false로 설정되어 위의 while 루프를 종료합니다. 이것은 꼭 필요한 것은 아니며 처음에는 이것을 무시했습니다. 그러나 while 루프를 종료하면 프로그램의 효율성이 크게 향상되고 프로그램 효율성은 일반적으로 고려해야 할 가치가 있다는 점에 유의해야합니다.

또한 플레이어가 잘못된 키를 입력 한 경우를 처리하는 함수를 만들고 호출했습니다. 이것은 나중에 다루게 될 것입니다.

### 5 단계

![](https://i.imgur.com/Bf7pG9W.png)  
이 함수는 하나의 함수를 위해 꽤 많은 시간을 쏟았습니다! 익숙해진다면 시간이 더 짧아질 것입니다.

불이 들어오는 LED를 결정하기 위해 0에서 4 사이의 임의의 정수를 사용합니다. (우리는 0으로 시작하는 색인을 사용하는데, 이는 왼쪽 상단이 (0,0)임을 의미 함)

미래의 어떤 시점에서 함수가 호출되기를 기대하면서, 일시 중지 시간을 줄여 게임이 더 어려워 질 때까지 기다립니다.
  
우리는 자체 수제 이벤트 리스너를 운영합니다 (이 이름은 그 기능을 배제합니다. 이벤트가 발생하기를 기다리지 만 미리 설정된 코드로 작동합니다). while 루프를 사용하여 이벤트를 수신합니다. 한 루프에서 이벤트를 찾지 못하면 내부의 if-else 문은 활성화되지 않으므로 다음 반복으로 진행됩니다. 이벤트가 발생하면 (이 경우 키를 누름) if-else 문이 잠자기에서 활성화되므로이 독창적 인 방식으로 이벤트 리스너를 만들었습니다. (확장 : 브라우저는 클릭 또는 키패드 프레스와 같은 이벤트를 동일한 방식으로 수신합니다.)


### 6 단계

![](https://i.imgur.com/Spxd5kb.png)  

각 if-else 문에서 잘못된 키패드를 누르면 게임을 종료하고 플레이어에게 우리가 생각하는 것을 말해줍니다.

오른쪽 키가 눌려지면, 우리는 즉시 루프 또는 효율성 목적을 종료하는 동안 다음 LED 표시등으로 이동합니다 (코드는 여전히 작동하지만 나쁜 습관을 조장하지 않는 것이 가장 좋습니다).
다음 LED 조명으로 진행하는 동안 우리는 재귀 (recursion)라는 개념을 사용합니다. 재귀의 내부 동작을 완전히 이해하려면 실행 문맥과 같은 개념에 익숙해야합니다.이 튜토리얼의 범위를 벗어납니다.


### 7 단계

![](https://i.imgur.com/tqrKglq.png)  

많은 일이 있었습니다.

결국 우리는 재귀 적으로 호출 할 수있는 멋진 함수를 만들었습니다. 게임이 단순화되어 그 핵심이 하나의 코드 블록에 있다는 것은 놀랍습니다!



### 8 단계

![](https://i.imgur.com/ijyeL83.png)  

이제는 짧게 코드를 짜 봅시다.
잃는 기능은 플레이어가 잘못된 키를 누를 때 호출 할 함수입니다. 대부분은 설명이 필요하지 않으며 이전 파트를 넘길 수 있다면 코드가하는 일이 분명해야합니다.


### 9 단계
![](https://i.imgur.com/Tn12M0k.png)  

이제 첫 번째 LED를 시작하십시오.
파일이 로드 될 때 함수를 호출합니다. 재귀 함수가 있어서, 게임은 최소한의 코딩으로 게임 그 자체를 실행 시킬 것입니다. 이 얼마나 효율적인가!

이 코드를 직접 입력하지 않으려면 아래 링크에서 전체 프로그램을 다운로드 할 수 있습니다.
https://makecode.microbit.org/_eeyAFJMcg8z5  

또는 아래 페이지에서 다운로드 할 수 있습니다.

<div style="position: relative; height: 0; padding-bottom: 70%; overflow: hidden;"><iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://makecode.microbit.org/#pub:_eeyAFJMcg8z5" width="300" height="150" frameborder="0" sandbox="allow-popups allow-forms allow-scripts allow-same-origin"></iframe></div>  
&nbsp;


## 굉장해!    
---

![](https://i.imgur.com/HVAtYai.jpg)

이 메뉴얼을 완료했습니다! 자신에게 더 도전하고 싶다면, 플레이어가 잃기 전에 얻은 점수를 세는 카운터를 추가하십시오. 단서 : counter라는 변수를 만들고 적당하다고 생각되는만큼 증가시킵니다. 그것을 표시하는 것을 잊지 마십시오!

이 튜토리얼은 나머지 부분보다 더 높은 레벨 일 가능성이 높습니다. 이것을 한다면 확실하게 달라져 있을 겁니다.. 당신이 이 메뉴얼을 보지 않고 만든다면 재귀와 같은 개념에 대해서 머리를 쓰는 데 몇 주가 걸렸습니다. 행운을 빕니다!
